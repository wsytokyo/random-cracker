"""
Utilities for cracking V8's Math.random().

This module provides converters to handle the two ways V8 converts the internal
state of its pseudo-random number generator (PRNG) into a double-precision float.
It also includes an implementation of the xorshift128+ algorithm and its reverse.

"""

import struct
from abc import ABC, abstractmethod

# A 64-bit mask (all bits set to 1).
UINT64_MASK = (1 << 64) - 1  # 0xFFFFFFFFFFFFFFFF

# The exponent bits for a double-precision float to be in the range [1.0, 2.0).
EXPONENT_MASK = struct.unpack("<Q", struct.pack("<d", 1.0))[0]  # 0x3FF0000000000000

# Represents 2^53, used in the division-based conversion method.
TWO_POW_53 = 1 << 53  # 0x20000000000000


class RNGStateConverter(ABC):
    """An interface for converting between a PRNG's internal integer state and a double.

    V8 has used different methods in history to convert the 64-bit integer state of its
    PRNG to a double in the range [0, 1). This class defines the interface
    for these conversion strategies.

    See: https://github.com/v8/v8/commit/e0609ce60acf83df5c6ecd8f1e02f771e9fc6538
    """

    @classmethod
    @abstractmethod
    def to_double(cls, state: int) -> float:
        """Converts a 64-bit integer state to a double in [0, 1)."""

    @classmethod
    @abstractmethod
    def from_double(cls, value: float) -> int:
        """Converts a double in [0, 1) back to a 64-bit integer state."""

    @classmethod
    @abstractmethod
    def get_ignored_lower_bits(cls) -> int:
        """Returns the number of lower bits that are ignored by the conversion."""


class BinaryCastConverter(RNGStateConverter):
    """Converter for older V8 versions that use binary casting.

    This method works by taking the upper 52 bits of the PRNG state, adding
    the exponent bits for the range [1.0, 2.0), and reinterpreting the bits
    as a double. Subtracting 1.0 then maps this to the desired [0, 1) range.
    """

    @classmethod
    def get_ignored_lower_bits(cls) -> int:
        """Returns the number of lower bits that are ignored by the conversion."""
        return 12

    @classmethod
    def to_double(cls, state: int) -> float:
        """Converts state to a double using the binary cast method."""
        # V8's xorshift128+ generates a 64-bit state. The double is created from
        # the top 52 bits. The lower 12 bits are discarded.
        state_upper_52_bits = state >> cls.get_ignored_lower_bits()

        # Set the exponent to create a double in the range [1.0, 2.0).
        state_with_exponent = state_upper_52_bits | EXPONENT_MASK

        # Pack the 64-bit integer into bytes as a little-endian unsigned long long.
        packed = struct.pack("<Q", state_with_exponent)
        # Unpack the bytes into a double-precision float.
        random_double = struct.unpack("<d", packed)[0]

        # The value is in [1.0, 2.0), so subtract 1.0 to map it to [0, 1).
        return random_double - 1.0

    @classmethod
    def from_double(cls, value: float) -> int:
        """Recovers the PRNG state from a double with range [0, 1) generated by the binary cast method."""

        # Reverse the subtraction to get back to the [1.0, 2.0) range.
        value_plus_one = value + 1.0

        # Pack the double into bytes.
        packed = struct.pack("<d", value_plus_one)
        # Unpack as a 64-bit integer. This recovers the state with the exponent mask.
        state_with_exponent = struct.unpack("<Q", packed)[0]

        # The original state was right-shifted by 12, so we left-shift to restore
        # its position. This leaves the lower 12 bits as zero, as they were
        # discarded in the `to_double` conversion and are therefore unknown.
        recovered_state = state_with_exponent << cls.get_ignored_lower_bits()

        return recovered_state & UINT64_MASK


class DivisionConverter(RNGStateConverter):
    """Converter for newer V8 versions that use division.

    This method works by taking the upper 53 bits of the PRNG state and
    dividing by 2^53 to produce a double in the range [0, 1).
    """

    @classmethod
    def get_ignored_lower_bits(cls) -> int:
        """Returns the number of lower bits that are ignored by the conversion."""
        return 11

    @classmethod
    def to_double(cls, state: int) -> float:
        """Converts state to a double using the division method."""
        # The upper 53 bits of the state are used.
        state_upper_53_bits = state >> cls.get_ignored_lower_bits()
        return float(state_upper_53_bits) / TWO_POW_53

    @classmethod
    def from_double(cls, value: float) -> int:
        """Recovers the PRNG state from a double with range [0, 1) generated by the division method."""

        # Reverse the division by multiplying and converting to an integer.
        state_upper_53_bits = int(value * TWO_POW_53)

        # Left-shift to restore the position. This leaves the lower 11 bits as
        # zero, as they were discarded in the `to_double` conversion and are
        # therefore unknown.
        recovered_state = state_upper_53_bits << cls.get_ignored_lower_bits()

        return recovered_state & UINT64_MASK


class XorShift128:
    """A utility class providing static methods for the xorshift128+ algorithm.

    This class is not meant to be instantiated. It provides a stateless
    implementation of the forward `next_state` function and its inverse,
    `previous_state`, which is essential for predicting previous PRNG states.
    """

    @classmethod
    def next_state(cls, s0: int, s1: int) -> tuple[int, int]:
        """Calculates the next state of the xorshift128+ PRNG."""
        s1_new = s0
        s1_new ^= (s1_new << 23) & UINT64_MASK
        s1_new ^= s1_new >> 17
        s1_new ^= s1
        s1_new ^= s1 >> 26
        return s1, s1_new

    @classmethod
    def previous_state(cls, s0: int, s1: int) -> tuple[int, int]:
        """Calculates the previous state of the xorshift128+ PRNG."""
        temp1 = s1 ^ s0 ^ (s0 >> 26)
        temp2 = temp1 ^ (temp1 >> 17) ^ (temp1 >> 34) ^ (temp1 >> 51)
        prev_s0 = (temp2 ^ (temp2 << 23) ^ (temp2 << 46)) & UINT64_MASK
        return prev_s0, s0
